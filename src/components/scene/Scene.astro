---
// ThreeScene.astro - No props needed for this basic example
---

<section class="relative h-screen w-full overflow-hidden bg-black dark:bg-black">
  {/* Background */}
  <div id="three-container" class="w-full h-full overflow-hidden bg-black relative"></div>

  {/* Content */}
  <div class="absolute inset-0 flex items-center justify-center z-10 pointer-events-none">
    <div class="text-center text-white max-w-5xl px-6">
      <h1 class="text-6xl md:text-8xl font-bold mb-6 bg-gradient-to-r from-white via-blue-200 to-violet-300 bg-clip-text text-transparent">
        DJ BRIAN RODRIGUEZ
      </h1>

      <div class="w-24 h-1 bg-gradient-to-r from-blue-500 to-purple-500 mx-auto mb-8 rounded-full"></div>

      <p class="text-xl md:text-2xl text-gray-200 mb-8 font-light">Creating Unforgettable Musical Experiences</p>
      <p class="text-lg text-gray-300 max-w-2xl mx-auto leading-relaxed">
        Professional DJ services for weddings, corporate events, and private parties. Bringing the perfect soundtrack to your most important moments.
      </p>

      <div class="mt-12">
        <a
          href="#about"
          class="inline-flex items-center px-8 py-4 bg-gradient-to-r from-blue-600 to-purple-600 text-white font-semibold rounded-2xl hover:from-blue-700 hover:to-purple-700 transition-all duration-300 transform hover:scale-105"
        >
          Discover More
          <svg class="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width={2} d="M19 14l-7 7m0 0l-7-7m7 7V3"></path>
          </svg>
        </a>
      </div>
    </div>
  </div>

  {/* Scroll indicator */}
  <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 text-white animate-bounce">
    <div class="w-6 h-10 border-2 border-white/30 rounded-full flex justify-center">
      <div class="w-1 h-3 bg-blue-400 rounded-full mt-2 animate-pulse"></div>
    </div>
  </div>
</section>

<script>
  import * as THREE from "three";
  import { CircleMesh } from "./CircleMesh";
  import { LightSource } from "./LightSource";
  import { EffectComposer, EffectPass, GodRaysEffect, RenderPass, BloomEffect, BlendFunction } from "postprocessing";

  // Debounce function to limit resize event calls -------------
  function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {
    let timeout: ReturnType<typeof setTimeout> | undefined;

    return function (this: any, ...args: Parameters<T>): void {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  // Scene initialization function -------------
  function initScene() {
    let mouseX = 0;
    let mouseY = 0;

    // Canvas container
    const container = document.getElementById("three-container") as HTMLElement;
    container.addEventListener("mousemove", (event) => {
      const rect = container.getBoundingClientRect();
      mouseX = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
      mouseY = -(((event.clientY - rect.top) / container.clientHeight) * 2 - 1);
    });

    const scene = new THREE.Scene();

    // Add atmospheric fog for depth and haze
    scene.fog = new THREE.FogExp2(0x000000, 0.005);

    // Camera
    let camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 1, 1000);
    camera.position.set(5, 0, 300);

    // Renderer
    let renderer = new THREE.WebGLRenderer({
      powerPreference: "high-performance",
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);
    window.addEventListener("resize", debounce(onResize, 250), false);

    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0x111111);
    scene.add(ambientLight);

    // Create main light source
    let light = new LightSource();
    light.position.set(2, 0, -10);
    scene.add(light);

    // Create grid figure with viewport dimensions
    let figure = new CircleMesh(5, 15, 15, container.clientWidth, container.clientHeight);
    scene.add(figure);

    // Create dust particles for atmospheric effect
    const dustParticles = createDustParticles();
    scene.add(dustParticles);

    // Create post-processing composer pipeline
    let composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    // Add god rays
    let gre = new GodRaysEffect(camera, light, {
      height: 720,
      kernelSize: 3,
      density: 1.2,
      decay: 0.92,
      weight: 0.6,
      exposure: 0.6,
      samples: 60,
      clampMax: 1.0,
    });
    composer.addPass(new EffectPass(camera, gre));

    let clock = new THREE.Clock();

    // Animation loop
    renderer.setAnimationLoop(() => {
      let t = clock.getElapsedTime();

      // Animate light
      light.userData.time.value = t;
      light.update(t, mouseX, mouseY);

      // Animate dust particles within bounds
      dustParticles.rotation.y = Math.sin(t * 0.1) * 0.5;
      dustParticles.rotation.x = Math.cos(t * 0.07) * 0.3;

      // Render the scene
      composer.render();
    });

    // Create dust particles for atmospheric effect
    function createDustParticles() {
      const particleCount = 100000;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      // Distribute particles in a volume
      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 400; // x
        positions[i + 1] = (Math.random() - 0.5) * 400; // y
        positions[i + 2] = (Math.random() - 0.5) * 200; // z
      }

      particles.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      // Create particle material
      const particleMaterial = new THREE.PointsMaterial({
        color: 0x888888,
        size: 0.5,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending,
      });

      return new THREE.Points(particles, particleMaterial);
    }

    // Handle window resize
    function onResize() {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);

      figure.resize(container.clientWidth, container.clientHeight);
    }
  }

  // Initialize the scene once the DOM is loaded
  document.addEventListener("DOMContentLoaded", initScene);
</script>
