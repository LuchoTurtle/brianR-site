---
// ThreeScene.astro - No props needed for this basic example
---
<section class="relative h-screen w-full overflow-hidden bg-black dark:bg-black">
  {/* Background */}
  <div id="three-container" class="w-full h-full overflow-hidden bg-black relative"></div>

  {/* Content */}
  <div class="absolute inset-0 flex items-center z-10 pointer-events-none">
    <div class="w-full px-6 pt-24 pb-0 sm:pt-32 sm:pb-0 lg:px-8 lg:pt-40 lg:pb-0">
      <div id="hero-text" class="text-center lg:text-left max-w-2xl mx-auto lg:mx-0 lg:ml-16 xl:ml-24 2xl:ml-32 transition-transform duration-200 ease-out">
        <h1 class="mt-10 tracking-tight text-white text-pretty text-4xl sm:text-6xl md:text-7xl lg:text-8xl font-bold mb-6">DJ Brian Rodrigues</h1>
        <p class="mt-8 text-pretty text-lg text-gray-300 leading-relaxed sm:text-xl/8">
          New Jersey's Premier Wedding & Event DJ â€¢ Creating Unforgettable Moments Through Music
        </p>
      </div>
    </div>

    {/* Scroll indicator */}
    <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 text-white animate-bounce">
      <div class="w-6 h-10 border-2 border-white/30 rounded-full flex justify-center">
        <div class="w-1 h-3 bg-blue-400 rounded-full mt-2 animate-pulse"></div>
      </div>
    </div>
  </div>

  <script>
    import * as THREE from "three";
    import { CircleMesh } from "./CircleMesh";
    import { LightSource } from "./LightSource";
    import { EffectComposer, EffectPass, GodRaysEffect, RenderPass, BloomEffect, BlendFunction } from "postprocessing";

    // Debounce function to limit resize event calls -------------
    function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {
      let timeout: ReturnType<typeof setTimeout> | undefined;

      return function (this: any, ...args: Parameters<T>): void {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    // Device detection using Tailwind's breakpoints
    function isDesktop(): boolean {
      // Tailwind's lg breakpoint is 1024px
      const isLargeScreen = window.innerWidth >= 1024;
      
      // Check if device has fine pointer (mouse) capability
      const hasFinePointer = window.matchMedia('(pointer: fine)').matches;
      
      // Check if device can hover (excludes most touch devices)
      const canHover = window.matchMedia('(hover: hover)').matches;
      
      // Combine checks - must be large screen AND have mouse capabilities
      return isLargeScreen && hasFinePointer && canHover;
    }

    // Scene initialization function -------------
    function initScene() {
      let mouseX = 0;
      let mouseY = 0;
      const isDesktopDevice = isDesktop();

      // Canvas container
      const container = document.getElementById("three-container") as HTMLElement;
      const heroText = document.getElementById("hero-text") as HTMLElement;

      // Only add mouse movement effects on desktop devices (lg and above)
      if (isDesktopDevice) {
        container.addEventListener("mousemove", (event) => {
          const rect = container.getBoundingClientRect();
          mouseX = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
          mouseY = -(((event.clientY - rect.top) / container.clientHeight) * 2 - 1);

          // Move hero text slightly with mouse (reduced movement)
          if (heroText) {
            const moveX = mouseX * 10; // Adjust multiplier for more/less movement
            const moveY = mouseY * 5;  // Smaller Y movement
            heroText.style.transform = `translate(${moveX}px, ${moveY}px)`;
          }
        });

        // Reset text position when mouse leaves
        container.addEventListener("mouseleave", () => {
          if (heroText) {
            heroText.style.transform = `translate(0px, 0px)`;
          }
        });
      }

      const scene = new THREE.Scene();

      // Add atmospheric fog for depth and haze
      scene.fog = new THREE.FogExp2(0x000000, 0.005);

      // Camera
      let camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 1, 1000);
      camera.position.set(5, 0, 300);

      // Renderer
      let renderer = new THREE.WebGLRenderer({
        powerPreference: "high-performance",
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      window.addEventListener("resize", debounce(onResize, 250), false);

      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x111111);
      scene.add(ambientLight);

      // Create main light source
      let light = new LightSource();
      light.position.set(2, 0, -10);
      scene.add(light);

      // Create grid figure with viewport dimensions
      let figure = new CircleMesh(5, 15, 15, container.clientWidth, container.clientHeight);
      scene.add(figure);

      // Create dust particles for atmospheric effect
      const dustParticles = createDustParticles();
      scene.add(dustParticles);

      // Create post-processing composer pipeline
      let composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));

      // Add god rays
      let gre = new GodRaysEffect(camera, light, {
        height: 720,
        kernelSize: 3,
        density: 1.2,
        decay: 0.92,
        weight: 0.6,
        exposure: 0.6,
        samples: 60,
        clampMax: 1.0,
      });
      composer.addPass(new EffectPass(camera, gre));

      let clock = new THREE.Clock();

      // Animation loop
      renderer.setAnimationLoop(() => {
        let t = clock.getElapsedTime();

        // Animate light - pass mouse coordinates only on desktop
        light.userData.time.value = t;
        light.update(t, isDesktopDevice ? mouseX : 0, isDesktopDevice ? mouseY : 0);

        // Animate dust particles within bounds
        dustParticles.rotation.y = Math.sin(t * 0.1) * 0.5;
        dustParticles.rotation.x = Math.cos(t * 0.07) * 0.3;

        // Render the scene
        composer.render();
      });

      // Create dust particles for atmospheric effect
      function createDustParticles() {
        const particleCount = 100000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);

        // Distribute particles in a volume
        for (let i = 0; i < particleCount * 3; i += 3) {
          positions[i] = (Math.random() - 0.5) * 400; // x
          positions[i + 1] = (Math.random() - 0.5) * 400; // y
          positions[i + 2] = (Math.random() - 0.5) * 200; // z
        }

        particles.setAttribute("position", new THREE.BufferAttribute(positions, 3));

        // Create particle material
        const particleMaterial = new THREE.PointsMaterial({
          color: 0x888888,
          size: 0.5,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending,
        });

        return new THREE.Points(particles, particleMaterial);
      }

      // Handle window resize
      function onResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);

        figure.resize(container.clientWidth, container.clientHeight);
      }
    }

    // Initialize the scene once the DOM is loaded
    document.addEventListener("DOMContentLoaded", initScene);
  </script>
</section>