---
// ThreeScene.astro - No props needed for this basic example
---

<div id="three-container"></div>

<script>
  import * as THREE from "three";
  import { CircleMesh } from "./CircleMesh";
  import { LightSource } from "./LightSource";
  import { EffectComposer, EffectPass, GodRaysEffect, RenderPass, BloomEffect, BlendFunction } from "postprocessing";

  // Debounce function to limit resize event calls -------------
  function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {
    let timeout: ReturnType<typeof setTimeout> | undefined;

    return function (this: any, ...args: Parameters<T>): void {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  // Scene initialization function -------------
  function initScene() {
    let mouseX = 0;
    let mouseY = 0;

    // Canvas container
    const container = document.getElementById("three-container") as HTMLElement;
    container.addEventListener("mousemove", (event) => {
      mouseX = (event.clientX / container.clientWidth) * 2 - 1;
      mouseY = -((event.clientY / container.clientHeight) * 2 - 1); // Negative to match Three.js Y-up
    });

    const scene = new THREE.Scene();

    // Add atmospheric fog for depth and haze
    scene.fog = new THREE.FogExp2(0x000000, 0.005);

    // Camera
    let camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 1, 1000);
    camera.position.set(5, 0, 300);

    // Renderer
    let renderer = new THREE.WebGLRenderer({
      powerPreference: "high-performance",
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);
    window.addEventListener("resize", debounce(onResize, 250), false);

    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0x111111);
    scene.add(ambientLight);

    // Create main light source
    let light = new LightSource();
    light.position.set(2, 0, -10);
    scene.add(light);

    // Create grid figure with viewport dimensions
    let figure = new CircleMesh(5, 15, 15, container.clientWidth, container.clientHeight);
    scene.add(figure);

    // Create dust particles for atmospheric effect
    const dustParticles = createDustParticles();
    scene.add(dustParticles);

    // Create post-processing composer pipeline
    let composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    // Add god rays
    let gre = new GodRaysEffect(camera, light, {
      height: 720,
      kernelSize: 3,
      density: 1.2,
      decay: 0.92,
      weight: 0.6,
      exposure: 0.6,
      samples: 60,
      clampMax: 1.0,
    });
    composer.addPass(new EffectPass(camera, gre));

    let clock = new THREE.Clock();

    // Animation loop
    renderer.setAnimationLoop(() => {
      let t = clock.getElapsedTime();

      // Animate light
      light.userData.time.value = t;
      light.update(t, mouseX, mouseY);

      // Animate dust particles within bounds
      dustParticles.rotation.y = Math.sin(t * 0.1) * 0.5;
      dustParticles.rotation.x = Math.cos(t * 0.07) * 0.3;

      // Render the scene
      composer.render();
    });

    // Create dust particles for atmospheric effect
    function createDustParticles() {
      const particleCount = 100000;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      // Distribute particles in a volume
      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 400; // x
        positions[i + 1] = (Math.random() - 0.5) * 400; // y
        positions[i + 2] = (Math.random() - 0.5) * 200; // z
      }

      particles.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      // Create particle material
      const particleMaterial = new THREE.PointsMaterial({
        color: 0x888888,
        size: 0.5,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending,
      });

      return new THREE.Points(particles, particleMaterial);
    }

    // Handle window resize
    function onResize() {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);

      figure.resize(container.clientWidth, container.clientHeight);
    }
  }

  // Initialize the scene once the DOM is loaded
  document.addEventListener("DOMContentLoaded", initScene);
</script>

<style>
  #three-container {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background-color: #000; /* Dark background to enhance contrast */
  }
</style>
